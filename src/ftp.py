from __future__ import annotations

import ftplib
import logging
import os
import ssl
from collections import defaultdict
from ftplib import FTP, error_perm

import arrow

import yaml
from src.mixins import DotDict, DotDictMixin

logger = logging.getLogger(__name__)



class ImplicitFTP_TLS(ftplib.FTP_TLS):
    """FTP_TLS subclass that automatically wraps sockets in SSL to support implicit FTPS.
    Source: https://stackoverflow.com/questions/12164470/python-ftp-implicit-tls-connection-issue"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._sock = None

    @property
    def sock(self):
        """Return the socket."""
        return self._sock

    @sock.setter
    def sock(self, value):
        """When modifying the socket, ensure that it is ssl wrapped."""
        if value is not None and not isinstance(value, ssl.SSLSocket):
            value = self.context.wrap_socket(value)
        self._sock = value

class FtpObjectBase(DotDictMixin):
    """Base class for defining objects representing components of an FTP library.
    """

    def __init__(self, name: str, ctype: str = None, size: str = None, modified: str = None, **kwargs):
        self.name: str = name
        self.ctype: str = ctype

        if size:
            self.size = int(size)
        else:
            self.size = size

        if modified:
            self.modified = arrow.Arrow.strptime(
                modified, '%Y%m%d%H%M%S', tzinfo='US/Central')
        else:
            self.modified = modified

    def __repr__(self):
        return f'<FtpObjectBase: {self.ctype} - {self.name}>'

    def __iter__(self):
        for k, v in self.__dict__.items():
            yield (k, v)

    def to_dict(self):
        """Transform the object's attributes to a representative dictionary

        Returns:
            DotDict -- dictionary of attributes
        """

        return DotDict(self.__iter__())

class FtpFile(FtpObjectBase):
    """Represents a file in the FTP library. Captures standard attributes associated to the file.
    """

    def __init__(self, name: str, ctype: str = None, size: str = None, modified: str = None, node: FtpNode = None):
        super().__init__(name, ctype, size, modified)
        self.name, self.ext = os.path.splitext(name)
        self.filename = name
        self._node = node
        self.path = self._node.path + self.filename

    def __repr__(self):
        return f'<FtpFile: {self.ctype} - {self.name}>'

    def download(self, destination: str = None) -> str:
        """Implementation of the core downloading function.  Each call to this
        method operates on a single file, downloading it to the designated locationself.

        Arguments:
            file {str} -- repsitory file path of file to download

        Keyword Arguments:
            destination {str} -- local download path. If not specified, the destination path used
            to instatiate the Ftp object is used. If it is also None, the download will fail. (default: {None})

        Returns:
            str -- filepath
        """

        destination = destination or self._node._ftp.destination

        if destination is None:
            raise AttributeError('Download destination has not been set.')

        try:
            with open(os.path.join(destination, self.filename), "wb") as f:
                self._node._ftp.retrbinary("RETR " + self.path, f.write)
                logger.info("Downloaded: " + self.filename)
                return os.path.join(destination, self.filename)
        except error_perm as e:
            logger.warning(f'{e} -- {self.filename}')

class FtpDirectory(FtpObjectBase):
    """Represents a directory in the FTP library. Captures standard attributes associated to the directory.
    """

    def __init__(self, name: str, ctype: str = None, size: str = None, modified: str = None, node: FtpNode = None):
        super().__init__(name, ctype, size, modified)
        self._node = node
        self.path = self._node.path

    def __repr__(self):
        return f'<FtpDirectory: {self.ctype} - {self.name}>'

def factory(name: str, properties: dict, node: FtpNode = None) -> FtpObjectBase:
    """Factory function for generating Ftp objects. All objects produced are subclasses of FtpObjectBase.

    Arguments:
        name {str} -- object name
        properties {dict} -- dictionary of properties generated by ftp.mlsd().

    Returns:
        Subclass of FtpObjectBase (file or directory)
    """
    properties = defaultdict(int, properties)
    if properties['type'].lower() == "file":
        return FtpFile(name, properties['type'], properties['size'], properties['modify'], node = node)
    if properties['type'].lower() == "dir":
        return FtpDirectory(name, properties['type'], properties['size'], properties['modify'], node = node)

class FtpNode(FtpObjectBase):
    """Captures attributes relating to a fork in the Ftp's file structure,
    usually a directory or symbolic link. Nodes model the relative structure
    of the connected repository and comprise the backbone of the search and
    retrieve capabilities of the Ftp class.
    """

    def __init__(self, path: str, level: int = 0, recurse: bool = True, ftp = None):
        self._ftp = ftp
        self.path: str = path + '/' if path != '/' else path
        properties = self._ftp.listing_from_path(self.path)
        super().__init__(name = os.path.basename(path), **properties)
        self.level: int = level
        self.objs: list = [factory(f, v, node = self) for f, v in properties.items()]
        self.dirs: list = [x for x in self.objs if isinstance(x, FtpDirectory)]
        self.files: list = [x for x in self.objs if isinstance(x, FtpFile)]
        self.nodes = {}
        self._add_children()


    def __repr__(self):
        return f'<FtpNode: path: [{self.path}], ndirs: [{self.ndirs}], nfiles: [{self.nfiles}]>'

    def __iter__(self):
        d = DotDict({file.filename: DotDict(file)
                          for file in self.files})

        if self.has_nodes:
            for name, node in self.nodes.items():
                d.update(DotDict({name: node.to_dict()}))

        yield self.path, DotDict(d)

    @property
    def has_nodes(self) -> bool:
        """Indicates if this node has any child nodes

        Returns:
            bool -- True indicates the presence of a child node
        """

        return len(self.dirs) > 0

    @property
    def has_dirs(self) -> bool:
        """Indicates if this node has any child nodes

        Returns:
            bool -- True indicates the presence of a child node
        """

        return len(self.dirs) > 0

    @property
    def ndirs(self) -> int:
        return len(self.dirs)

    @property
    def nfiles(self) -> int:
        return len(self.files)


    def download(self, destination: str = None) -> list:
        """Download all files in this Node.

            Returns:
                    list of paths to downloaded files.
        """
        return [f.download(destination = destination) for f in self.files]



    def contents(self) -> dict:
        """Return a listing of the contents in the ftp directory specified by the
        input path. If no path is specified, returns the listing of the ftp's root
        directory.

        Arguments:
            path {str} -- path do a directory on the ftp server

        Returns:
            DotDict -- dictionary of the directory's files and folders
        """

        return DotDict(self._ftp.mlsd(self.path))

    def paths(self):
        return [self.path + '/' + x.path for x in self.files]

    @property
    def modified(self):
        if self.nfiles > 0:
            return max([m.modified for m in self.files])
        else:
            return None

    def to_dict(self) -> dict:
        # if self.has_nodes:
            return next(self.__iter__())

    def add_child(self, node_path: str, level: int, ftp):
        node = FtpNode(node_path, level = self.level + 1, ftp = self._ftp)
        self.nodes.update({node_path: node})
        return node

    def _add_children(self):
        for d in self.dirs:
            self.add_child(self.path +'/' + d.name, level = self.level + 1, ftp = self._ftp)


    @property
    def children(self):
        return [node for node in self.nodes]

class Ftp(ImplicitFTP_TLS):
    """Extends ftplib.FTP, adding components to integrate with an FtpModel
    object to facilitate directory navigation, file listing, and downloading.
    """
    _basepath = '/'

    def __init__(self, url: str, username: str, password: str, destination: str = None, basepath: str = None, **kwargs):
        super().__init__()
        self.url = url
        self.username = username
        self.password = password
        self.destination = destination
        self.ssl_version = ssl.PROTOCOL_SSLv23
        self.connect(host=url, port=990)
        self.login(username, password)
        self.m = None  # model hook
        self.basepath = basepath or '.'
        print(self.cwd(self.basepath))


    @property
    def basepath(self):
        return self._basepath

    @basepath.setter
    def basepath(self, path: str) -> None:
        if path == self._basepath:
            logger.info('''Attempt to alter basepath resulted in no change. The current
                        value of basepath is equal to the provided value:\n
                        {self._basepath}'''.format(self._basepath))
        else:
            try:
                self._basepath = path
                self.cwd(self.basepath)
                logger.info(f'Basepath changed to {self._basepath}')
            except:
                logger.warning(f'Could not change basepath to {self._basepath}')


    def list_files(self, path: str = None, contains: str = '.') -> list:
        """Return a listing of the contents in the ftp directory specified by the
        input path. If no path is specified, returns the listing of the ftp's root
        directory.

        Contents of the directory are filtered according to the 'contains' parameter.

        Arguments:
            path {str} -- path do a directory on the ftp server (default: None)
            contains(str) -- string qualifying file names that should be returned
                             (default: '.')

        Returns:
            list -- a list of file names
        """

        return [ file for file in self.nlst(path or self.basepath) if contains in file ]

    @staticmethod
    def load(filename: str = None) -> Ftp:
        """Create an Ftp object from environment variables. Looks for environment
           variables prefixed with "FSEC_" that correspond to the required parameter
           name.

           FSEC_URL = Url to ftp site (e.g. provier.domain.com)
           FSEC_USERNAME = Username credential
           FSEC_PASSWORD = Password credential
           FSEC_BASEPATH = Path to the ftp directory containing the frac schedules
                           (e.g. /example/path/to/frac_schedules/)
           FSEC_DESTINATION = Path to location to save downloaded files


        Returns:
            Ftp
        """

        return Ftp(
            url = os.environ.get('FSEC_URL'),
            username = os.environ.get('FSEC_USERNAME'),
            password = os.environ.get('FSEC_PASSWORD'),
            basepath = os.environ.get('FSEC_BASEPATH'),
            destination = os.environ.get('FSEC_DESTINATION')
        )

    def download_all(self, destination: str = None) -> str:
        """Downloads all files located in the ftp directory located at the basepaths.

        Keyword Arguments:
            destination {str} -- local download path. If not specified, the destination path used to instatiate the Ftp object is used. If it is also None, the download will fail. (default: {None})

        Returns:
            list -- returns the list of tuples containing the downloaded file's
                    destination and name.

                    (e.g. filepath, filename, download_status)

        """
        results = [self.download(filename) for filename in self.list_files()]

        for r in results:
            print(f'{r[0]:<10}  {r[1]:<60}  {r[2]:<20}')

        return results

    def download(self, filename: str, destination: str = None) -> str:
        """Implementation of the core downloading function.  Each call to this
        method operates on a single file, downloading it to the designated location.

        Arguments:
            file {str} -- repsitory file path of file to download

        Keyword Arguments:
            destination {str} -- local download path. If not specified, the destination path used to instatiate the Ftp object is used. If it is also None, the download will fail. (default: {None})

        Returns:
            tuple -- (filepath, filename, download_status)
        """

        destination = destination or self.destination
        status = 'ERROR'

        if destination is None:
            raise AttributeError('Download destination has not been set.')

        try:
            with open(os.path.join(destination, filename), "wb") as f:
                self.retrbinary("RETR " + filename, f.write)
                logger.info("Downloaded: " + filename)
            status = 'success'

        except error_perm as e:
            logger.warning(f'{e} -- {filename}')

        return (destination, filename, status)

if __name__ == "__main__":

    # Example
    logging.basicConfig()
    logger.setLevel(logging.DEBUG)

    ftp = Ftp.from_env()
    # ftp = Ftp.from_yaml('config/config.yaml')

